# はじむ リファレンスマニュアル

> 🇺🇸 **English version available:** [REFERENCE_en.md](REFERENCE_en.md)

## 概要

はじむは、日本語の自然な表現を活かしたプログラミング言語です。
C言語で実装されたインタプリタにより実行されます。

## 目次

1. [基本構文](#基本構文)
2. [データ型](#データ型)
3. [演算子](#演算子)
4. [制御構造](#制御構造)
5. [関数](#関数)
6. [ラムダ（無名関数）](#ラムダ無名関数)
7. [クラス](#クラス)
8. [例外処理](#例外処理)
9. [モジュール](#モジュール)
10. [標準ライブラリ](#標準ライブラリ)
11. [高階配列関数](#高階配列関数)
12. [正規表現](#正規表現)
13. [システムユーティリティ](#システムユーティリティ)
14. [JSON](#json)
15. [HTTP通信](#http通信)
16. [Webhook/HTTPサーバー](#webhookhttpサーバー)
17. [非同期処理](#非同期処理)
18. [並列処理](#並列処理)
19. [スケジューラ](#スケジューラ)
20. [WebSocket](#websocket)
21. [列挙型](#列挙型)
22. [パターンマッチング](#パターンマッチング)
23. [ジェネレータ](#ジェネレータ)
24. [コマンドライン引数](#コマンドライン引数)
25. [デバッグ](#デバッグ)
26. [集合（セット）](#集合セット)
27. [演算子オーバーロード](#演算子オーバーロード)
28. [デコレータ](#デコレータ)
29. [アクセス修飾子](#アクセス修飾子)
30. [テストフレームワーク](#テストフレームワーク)
31. [カスタム例外](#カスタム例外)
32. [ドキュメントコメント](#ドキュメントコメント)
33. [型エイリアス](#型エイリアス)
34. [モジュール名前空間](#モジュール名前空間)
35. [パッケージ管理](#パッケージ管理)
36. [C拡張プラグイン](#c拡張プラグイン)
37. [リスト内包表記](#リスト内包表記)

---

## 基本構文

### コメント

```
// 一行コメント

/* 
   複数行コメント
*/
```

### 変数と定数

```
変数 名前 = "太郎"        // 変更可能な変数
定数 円周率 = 3.14159     // 変更不可能な定数
```

### 型注釈（オプション）

```
変数 数 は 数値 = 42
変数 名前 は 文字列 = "こんにちは"
```

---

## データ型

| 型 | 説明 | 例 |
|---|---|---|
| 数値 | 浮動小数点数 | `42`, `3.14`, `-17` |
| 文字列 | テキスト | `"こんにちは"` |
| 真偽 | ブール値 | `真`, `偽` |
| 配列 | 順序付きコレクション | `[1, 2, 3]` |
| 辞書 | キーと値のペア | `{"名前": "太郎", "年齢": 25}` |
| 無 | 値なし | `無` |
| ジェネレータ | 遅延値生成 | `生成関数` で作成 |

---

## 演算子

### 算術演算子

| 演算子 | 説明 |
|---|---|
| `+` | 加算 |
| `-` | 減算 |
| `*` | 乗算 |
| `/` | 除算 |
| `%` | 剰余 |
| `**` | べき乗 |

### 比較演算子

| 演算子 | 説明 |
|---|---|
| `==` | 等しい |
| `!=` | 等しくない |
| `<` | 小さい |
| `>` | 大きい |
| `<=` | 以下 |
| `>=` | 以上 |

### 論理演算子

| 演算子 | 説明 |
|---|---|
| `かつ` | 論理積 (AND) |
| `または` | 論理和 (OR) |
| `でない` | 論理否定 (NOT) |

### パイプ演算子

左辺の値を右辺の関数の第一引数として渡します。関数合成に便利です。

```
関数 二倍(数):
    戻す 数 * 2
終わり

関数 足す十(数):
    戻す 数 + 10
終わり

変数 結果 = 5 |> 二倍 |> 足す十  // (5 * 2) + 10 = 20
表示(結果)  // 20
```

### ビット演算関数

ビット単位の演算を行う関数群です。

| 関数 | 説明 | 例 |
|---|---|---|
| `ビット積(a, b)` | ビット論理積 | `ビット積(12, 10)` → 8 |
| `ビット和(a, b)` | ビット論理和 | `ビット和(12, 10)` → 14 |
| `ビット排他(a, b)` | ビット排他的論理和 | `ビット排他(12, 10)` → 6 |
| `ビット否定(a)` | ビット論理否定 | `ビット否定(0)` → -1 |
| `左シフト(a, b)` | 左ビットシフト | `左シフト(1, 4)` → 16 |
| `右シフト(a, b)` | 右ビットシフト | `右シフト(16, 2)` → 4 |

### 三項演算子

条件によって値を選択します。

```
変数 結果 = (x > 0) ? "正" : "非正"
変数 最大値 = (a > b) ? a : b
```

### Null合体演算子

左辺が `無` の場合、右辺の値を使います。

```
変数 名前 = 無
変数 表示名 = 名前 ?? "ゲスト"  // "ゲスト"

変数 値 = "太郎"
変数 結果 = 値 ?? "既定値"  // "太郎"
```

---

## 制御構造

### 条件分岐

```
もし 条件 なら
    // 条件が真の場合
それ以外
    // 条件が偽の場合
終わり
```

### 条件分岐チェーン（else-if）

複数の条件を連続して評価します。`それ以外もし` キーワードを使用します。

```
関数 成績(点数):
    もし 点数 >= 90 なら
        戻す "優"
    それ以外もし 点数 >= 70 なら
        戻す "良"
    それ以外もし 点数 >= 50 なら
        戻す "可"
    それ以外
        戻す "不可"
    終わり
終わり
```

### ループ

#### 条件ループ

```
条件 x < 10 の間
    表示(x)
    x = x + 1
終わり
```

#### 範囲ループ

```
i を 1 から 10 繰り返す
    表示(i)
終わり
```

### ループ制御

```
抜ける     // ループを抜ける
続ける     // 次の繰り返しへ
```

### 各要素ループ（foreach）

配列、文字列、辞書の各要素に対して処理を行います。

```
変数 果物 = ["りんご", "みかん", "ぶどう"]
各 名前 を 果物 の中:
    表示(名前)
終わり
```

#### 文字列の各文字

```
各 文字 を "こんにちは" の中:
    表示(文字)
終わり
```

#### 辞書のキー

```
変数 情報 = {"名前": "太郎", "年齢": "25"}
各 項目 を 情報 の中:
    表示(項目)  // "名前", "年齢"
終わり
```

### 選択文（switch）

値に応じて処理を分岐します。

```
選択 値:
    場合 1:
        表示("一")
    場合 2:
        表示("二")
    場合 3:
        表示("三")
    既定:
        表示("その他")
終わり
```

---

## 関数

### 関数定義

```
関数 挨拶(名前):
    表示("こんにちは、" + 名前 + "さん")
終わり
```

### 戻り値

```
関数 足し算(a, b):
    戻す a + b
終わり

変数 結果 = 足し算(3, 5)
```

> **注**: `戻す` と `返す` は同義です。どちらも関数の戻り値を指定するキーワードとして使用できます。

### 型注釈付き関数

```
関数 掛け算(x は 数値, y は 数値) は 数値:
    戻す x * y
終わり
```

### デフォルト引数

関数の引数にデフォルト値を指定することで、呼び出し時に引数を省略できます。

```
関数 挨拶(名 = "ゲスト", 接頭 = "こんにちは"):
    戻す 接頭 + "、" + 名 + "！"
終わり

表示(挨拶())                    // "こんにちは、ゲスト！"
表示(挨拶("太郎"))            // "こんにちは、太郎！"
表示(挨拶("太郎", "やあ"))   // "やあ、太郎！"
```

### 可変長引数

`*` を引数名の前に付けることで、任意の数の引数を配列として受け取ります。

```
関数 合計(*数列):
    変数 結果 = 0
    各 数 を 数列 の中:
        結果 = 結果 + 数
    終わり
    戻す 結果
終わり

表示(合計(1, 2, 3))       // 6
表示(合計(10, 20, 30, 40)) // 100
```

### スプレッド演算子

関数呼び出し時に配列を展開して引数として渡します。

```
関数 足し算(a, b, c):
    戻す a + b + c
終わり

変数 値 = [10, 20, 30]
表示(足し算(...値))  // 60
```

### 分解代入

配列の要素を個別の変数に分解して代入します。

```
変数 [a, b, c] = [1, 2, 3]
表示(a)  // 1
表示(b)  // 2
表示(c)  // 3
```

---

## ラムダ（無名関数）

名前のない関数を作成して変数に代入したり、引数として渡すことができます。

### 基本構文

```
変数 二倍 = 関数(x):
    戻す x * 2
終わり

表示(二倍(5))  // 10
```

### 引数として渡す

```
変数 数列 = [1, 2, 3, 4, 5]
変数 結果 = 変換(数列, 関数(x):
    戻す x * 10
終わり)
表示(結果)  // [10, 20, 30, 40, 50]
```

### クロージャ

ラムダは定義時のスコープの変数を捕捉します。

```
関数 掛け算器(倍率):
    戻す 関数(x):
        戻す x * 倍率
    終わり
終わり

変数 三倍 = 掛け算器(3)
表示(三倍(5))  // 15
```

---

## クラス

### クラス定義

```
型 人:
    初期化(名前, 年齢):
        自分.名前 = 名前
        自分.年齢 = 年齢
    終わり

    関数 自己紹介():
        表示("私は" + 自分.名前 + "、" + 文字列化(自分.年齢) + "歳です")
    終わり
終わり
```

### インスタンス作成

```
変数 太郎 = 新規 人("太郎", 25)
太郎.自己紹介()
```

### 継承

```
型 学生 継承 人:
    初期化(名前, 年齢, 学校):
        自分.名前 = 名前
        自分.年齢 = 年齢
        自分.学校 = 学校
    終わり

    関数 通学():
        表示(自分.名前 + "は" + 自分.学校 + "に通っています")
    終わり
終わり
```

### super呼び出し（親メソッド）

`親.メソッド名(引数)` で親クラスのメソッドを呼び出します。

```
型 動物:
    初期化(名前):
        自分.名前 = 名前
    終わり

    関数 挨拶():
        戻す 自分.名前 + "です"
    終わり
終わり

型 犬 継承 動物:
    初期化(名前, 種類):
        親.初期化(名前)
        自分.種類 = 種類
    終わり

    関数 挨拶():
        変数 基本 = 親.挨拶()
        戻す 基本 + "（" + 自分.種類 + "）"
    終わり
終わり
```

### 静的メソッド

`静的 関数` でクラスに属するメソッドを定義します。インスタンスを作成せずに `クラス名.メソッド名()` で呼び出せます。

```
型 数学ツール:
    初期化():
    終わり

    静的 関数 足す(a, b):
        戻す a + b
    終わり

    静的 関数 掛ける(a, b):
        戻す a * b
    終わり
終わり

表示(数学ツール.足す(3, 5))    // 8
表示(数学ツール.掛ける(4, 6))  // 24
```

### 型判定（instanceof）

`型判定(オブジェクト, "クラス名")` でオブジェクトの型を判定します。

```
変数 太郎 = 新規 人("太郎", 25)
表示(型判定(太郎, "人"))    // 真
表示(型判定(太郎, "学生"))  // 偽
```

---

## 例外処理

### 基本構文

```
試行:
    // 例外が発生する可能性のあるコード
    投げる "エラーが発生しました"
捕獲 エラー:
    表示("エラー: " + エラー)
最終:
    // 必ず実行されるコード
終わり
```

---

## モジュール

### モジュールのインポート

`取り込む` 文を使って外部ファイルを読み込みます。

```
// ファイルパスによるインポート
取り込む "数学.jp"
取り込む "utils/helpers.jp"

// パッケージ名によるインポート（パッケージ管理と連携）
取り込む "my-package"
```

### パス解決の順序

`取り込む` 文はファイルパスを以下の順序で解決します：

1. **呼び出し元ファイルからの相対パス** — 現在実行中のファイルのディレクトリを基準
2. **カレントディレクトリからの相対パス** — 実行時のワーキングディレクトリを基準
3. **パッケージ検索** — `hajimu_packages/` および `~/.hajimu/packages/` を検索

### パスの種類

```
// ファイルパス（/ または .jp を含む）
取り込む "lib/math_utils.jp"   // 相対パス
取り込む "utils/helpers"       // .jp は省略可能

// パッケージ名（/ を含まない）
取り込む "my-package"          // パッケージとして検索
```

### 重複インポートの防止

同じファイルは一度だけ読み込まれます。2回目以降の `取り込む` は無視されます。

```
取り込む "utils.jp"  // 読み込まれる
取り込む "utils.jp"  // 既に読み込み済み → スキップ
```

### 循環参照の検出

循環的なインポートは自動的に検出され、無限ループを防止します。

---

## 標準ライブラリ

### 入出力

| 関数 | 説明 | 例 |
|---|---|---|
| `表示(...)` | 出力 | `表示("こんにちは")` |
| `入力(プロンプト)` | 入力 | `変数 名前 = 入力("名前: ")` |

### コレクション

| 関数 | 説明 |
|---|---|
| `長さ(値)` | 配列・文字列の長さ |
| `追加(配列, 値)` | 配列に要素を追加 |
| `削除(配列, インデックス)` | 要素を削除 |
| `ソート(配列)` | ソート |
| `逆順(配列)` | 逆順 |
| `スライス(配列, 開始, 終了)` | 部分配列 |
| `位置(配列, 値)` | インデックスを取得 |
| `存在(配列, 値)` | 値が存在するか |
| `末尾削除(配列)` | 末尾要素を削除して返す |
| `探す(配列, 関数)` | 条件に合う最初の要素 |
| `全て(配列, 関数)` | 全要素が条件を満たすか |
| `一つでも(配列, 関数)` | 一つでも条件を満たすか |
| `一意(配列)` | 重複を除去 |
| `圧縮(配列1, 配列2)` | 2つの配列をペアに |
| `平坦化(配列)` | ネストを平坦化 |
| `挿入(配列, 位置, 値)` | 指定位置に挿入 |
| `比較ソート(配列, 関数)` | カスタム比較でソート |

### 型変換

| 関数 | 説明 |
|---|---|
| `数値化(値)` | 数値に変換 |
| `文字列化(値)` | 文字列に変換 |

### 数学関数

| 関数 | 説明 |
|---|---|
| `絶対値(数)` | 絶対値 |
| `平方根(数)` | 平方根 |
| `切り捨て(数)` | 切り捨て |
| `切り上げ(数)` | 切り上げ |
| `四捨五入(数)` | 四捨五入 |
| `最大(値...)` | 最大値 |
| `最小(値...)` | 最小値 |
| `乱数()` | 0-1の乱数 |
| `乱数整数(最小, 最大)` | 範囲内の整数乱数 |
| `正弦(角度)` | サイン (sin) |
| `余弦(角度)` | コサイン (cos) |
| `正接(角度)` | タンジェント (tan) |
| `対数(値)` | 自然対数 (ln) |
| `常用対数(値)` | 常用対数 (log10) |

### 数学定数

| 定数 | 説明 | 値 |
|---|---|---|
| `円周率` | π | 3.14159265... |
| `自然対数の底` | e | 2.71828182... |

### 文字列操作

| 関数 | 説明 |
|---|---|
| `分割(文字列, 区切り)` | 文字列を分割 |
| `結合(配列, 区切り)` | 配列を結合 |
| `置換(文字列, 検索, 置換)` | 文字列を置換 |
| `大文字(文字列)` | 大文字に変換 |
| `小文字(文字列)` | 小文字に変換 |
| `空白除去(文字列)` | 前後の空白を除去 |
| `検索(文字列, 検索語)` | 位置を検索 |
| `部分文字列(文字列, 開始, 終了)` | 部分文字列を取得 |
| `始まる(文字列, 接頭辞)` | 接頭辞で始まるか |
| `終わる(文字列, 接尾辞)` | 接尾辞で終わるか |
| `文字コード(文字列 [, 位置])` | 文字コードを取得 |
| `コード文字(コード)` | コードから文字を生成 |
| `繰り返し(文字列, 回数)` | 文字列を繰り返す |

### 文字列補間 (String Interpolation)

文字列内に `{}` を使用して式を埋め込むことができます。

```
変数 名前 = "太郎"
変数 年齢 = 25
表示("{名前}は{年齢}歳")  // "太郎は25歳"
表示("{1 + 2 + 3}")     // "6"
```

### 複数行文字列 (Multi-line String)

`"""..."""` で囲むことで改行を含む文字列を作成できます。

```
変数 複数行 = """これは
複数行の
文字列です"""

表示(複数行)
```

### 範囲関数

様々な範囲を生成します。

| 関数 | 説明 | 例 |
|---|---|---|
| `範囲(終了)` | 0から終了まで | `範囲(5)` → [0,1,2,3,4] |
| `範囲(開始, 終了)` | 開始から終了まで | `範囲(2, 5)` → [2,3,4] |
| `範囲(開始, 終了, ステップ)` | ステップ指定 | `範囲(0, 10, 2)` → [0,2,4,6,8] |

### ファイル操作

| 関数 | 説明 |
|---|---|
| `読み込む(パス)` | ファイル読み込み |
| `書き込む(パス, 内容)` | ファイル書き込み |
| `ファイル存在(パス)` | ファイル存在確認 |
| `追記(パス, 内容)` | ファイルに追記 |
| `ディレクトリ一覧(パス)` | ディレクトリ内容一覧 |
| `ディレクトリ作成(パス)` | ディレクトリ作成 |

### 日時

| 関数 | 説明 |
|---|---|
| `現在時刻()` | Unixタイムスタンプ |

### 型チェック関数

値の型を判定します。すべて真偽値を返します。

| 関数 | 説明 |
|---|---|
| `数値か(値)` | 数値かどうか判定 |
| `文字列か(値)` | 文字列かどうか判定 |
| `真偽か(値)` | 真偽値かどうか判定 |
| `配列か(値)` | 配列かどうか判定 |
| `辞書か(値)` | 辞書かどうか判定 |
| `関数か(値)` | 関数かどうか判定 |
| `無か(値)` | nullかどうか判定 |
| `日付()` | 現在の日付 (YYYY-MM-DD) |
| `時間()` | 現在の時刻 (HH:MM:SS) |

### ユーティリティ

| 関数 | 説明 |
|---|---|
| `表明(条件 [, メッセージ])` | アサーション（条件が偽ならエラー） |
| `型判定(値, "型名")` | 型名が一致するか判定 |

### 負のインデックス

配列・文字列で負のインデックスを使い、末尾から要素にアクセスできます。

```
変数 配列 = [10, 20, 30, 40, 50]
表示(配列[-1])   // 50（最後の要素）
表示(配列[-2])   // 40（後ろから2番目）
```

### 辞書操作

| 関数 | 説明 |
|---|---|
| `キー(辞書)` | キーの配列 |
| `値一覧(辞書)` | 値の配列 |
| `含む(辞書, キー)` | キーの存在確認 |

---

## 高階配列関数

配列の各要素に関数を適用する高階関数です。

### 変換（map）

配列の各要素に関数を適用して新しい配列を返します。

```
変数 数列 = [1, 2, 3, 4, 5]
変数 二倍 = 変換(数列, 関数(x):
    戻す x * 2
終わり)
表示(二倍)  // [2, 4, 6, 8, 10]
```

### 抽出（filter）

条件に合う要素だけを抽出します。

```
変数 偶数 = 抽出([1, 2, 3, 4, 5], 関数(x):
    戻す x % 2 == 0
終わり)
表示(偶数)  // [2, 4]
```

### 集約（reduce）

配列を一つの値に集約します。第3引数は初期値です。

```
変数 合計 = 集約([1, 2, 3, 4, 5], 関数(acc, x):
    戻す acc + x
終わり, 0)
表示(合計)  // 15
```

### 反復（forEach）

配列の各要素に対して関数を実行します（戻り値なし）。

```
反復(["A", "B", "C"], 関数(x):
    表示("要素:", x)
終わり)
```

---

## 正規表現

POSIX拡張正規表現を使用したパターンマッチングです。

### 正規一致(文字列, パターン)

文字列がパターンにマッチするか判定します。

```
表示(正規一致("hello123", "[a-z]+[0-9]+"))  // 真
表示(正規一致("hello", "[0-9]+"))            // 偽
```

### 正規検索(文字列, パターン)

パターンにマッチした部分の配列を返します。最初の要素は全体マッチ、以降はグループです。

```
変数 結果 = 正規検索("電話: 03-1234-5678", "[0-9]+-[0-9]+-[0-9]+")
表示(結果)  // [03-1234-5678]
```

### 正規置換(文字列, パターン, 置換文字列)

パターンにマッチした全ての部分を置換します。

```
変数 結果 = 正規置換("abc 123 def 456", "[0-9]+", "XXX")
表示(結果)  // abc XXX def XXX
```

---

## システムユーティリティ

### 待つ(秒数)

指定秒数だけプログラムを一時停止します（小数可）。

```
待つ(1.5)  // 1.5秒停止
```

### 実行(コマンド)

シェルコマンドを実行し、出力を文字列で返します。

```
変数 結果 = 実行("ls -la")
表示(結果)
```

### 環境変数(名前)

環境変数の値を取得します。

```
変数 ホーム = 環境変数("HOME")
表示(ホーム)  // /Users/username
```

### 環境変数設定(名前, 値)

環境変数を設定します。

```
環境変数設定("MY_VAR", "テスト値")
表示(環境変数("MY_VAR"))  // テスト値
```

### 終了([コード])

プログラムを終了します。終了コードはオプションです（デフォルト: 0）。

```
終了()    // 正常終了
終了(1)   // エラー終了
```

---

## JSON

JSONの解析と生成ができます。

### JSON化(値)

値をJSON文字列に変換します。

```
変数 データ = {"名前": "太郎", "年齢": 25, "趣味": ["読書", "ゲーム"]}
変数 json = JSON化(データ)
表示(json)  // {"名前":"太郎","年齢":25,"趣味":["読書","ゲーム"]}
```

### JSON解析(文字列)

JSON文字列を値（辞書・配列等）に変換します。

```
変数 結果 = JSON解析("{\"name\":\"Taro\",\"age\":25}")
表示(結果["name"])  // Taro
表示(結果["age"])   // 25
```

---

## HTTP通信

libcurlを使ったHTTPクライアント機能です。全ての関数は結果を辞書で返します。

### レスポンス辞書の構造

| キー | 説明 |
|---|---|
| "状態" | HTTPステータスコード（200, 404等） |
| "本文" | レスポンスボディ（文字列） |
| "ヘッダー" | レスポンスヘッダー（辞書） |
| "エラー" | エラーメッセージ（失敗時） |

### HTTP取得(URL [, ヘッダー])

GETリクエストを送信します。

```
変数 応答 = HTTP取得("https://api.example.com/data")
表示(応答["状態"])   // 200
表示(応答["本文"])   // レスポンスボディ

// JSONレスポンスをパース
変数 データ = JSON解析(応答["本文"])
```

### HTTP送信(URL, ボディ [, ヘッダー])

POSTリクエストを送信します。ボディが辞書・配列の場合、自動的にJSONに変換されます。

```
// 辞書を自動JSON化してPOST
変数 結果 = HTTP送信("https://api.example.com/users", {"名前": "太郎"})

// 文字列をそのままPOST
変数 結果2 = HTTP送信("https://api.example.com/data", "raw body")

// カスタムヘッダー付き
変数 ヘッダー = {"Authorization": "Bearer TOKEN"}
変数 結果3 = HTTP送信("https://api.example.com/data", {"値": 1}, ヘッダー)
```

### HTTP更新(URL, ボディ [, ヘッダー])

PUTリクエストを送信します。使い方はHTTP送信と同じです。

### HTTP削除(URL [, ヘッダー])

DELETEリクエストを送信します。

```
変数 結果 = HTTP削除("https://api.example.com/users/1")
```

### HTTPリクエスト(メソッド, URL [, ボディ, ヘッダー])

任意のHTTPメソッドでリクエストを送信します。

```
変数 結果 = HTTPリクエスト("PATCH", "https://api.example.com/users/1", {"名前": "花子"})
```

### URLエンコード(文字列) / URLデコード(文字列)

URLエンコード/デコードを行います。

```
変数 エンコード済 = URLエンコード("こんにちは 世界")
表示(エンコード済)  // %E3%81%93%E3%82%93...

変数 デコード済 = URLデコード(エンコード済)
表示(デコード済)  // こんにちは 世界
```

---

## Webhook/HTTPサーバー

簡易HTTPサーバーを起動してWebhookを受信できます。

### サーバー起動(ポート [, タイムアウト秒])

指定ポートでHTTPリクエストを1件受信し、リクエスト情報を辞書で返します。
デフォルトタイムアウトは60秒です。

```
// Webhook受信
変数 リクエスト = サーバー起動(8080)
表示(リクエスト["メソッド"])  // POST
表示(リクエスト["パス"])      // /webhook
表示(リクエスト["本文"])      // リクエストボディ
表示(リクエスト["データ"])    // JSON自動パース済み
```

### リクエスト辞書の構造

| キー | 説明 |
|---|---|
| "メソッド" | HTTPメソッド（GET, POST等） |
| "パス" | リクエストパス |
| "本文" | リクエストボディ（文字列） |
| "ヘッダー" | リクエストヘッダー（辞書） |
| "クエリ" | クエリ文字列 |
| "データ" | JSON本文の自動パース結果 |

### 実用例: Webhookリスナー

```
// 無限ループでWebhookを待ち受け
変数 続行 = 真
条件 続行 の間
    変数 リクエスト = サーバー起動(8080, 300)
    変数 メソッド = リクエスト["メソッド"]
    もし メソッド なら
        表示("受信: " + メソッド + " " + リクエスト["パス"])
        表示("データ: " + 文字列化(リクエスト["データ"]))
    終わり
終わり
```

### 実用例: APIクライアント

```
// 外部APIからデータ取得して加工
変数 応答 = HTTP取得("https://jsonplaceholder.typicode.com/posts/1")
もし 応答["状態"] == 200 なら
    変数 記事 = JSON解析(応答["本文"])
    表示("タイトル: " + 記事["title"])
それ以外
    表示("エラー: " + 文字列化(応答["状態"]))
終わり
```

---

## 非同期処理

非同期タスクの実行と待機を行います。

### 非同期実行(関数 [, 引数...])

関数を非同期タスクとして実行し、タスクIDを返します。

```
関数 重い処理():
    待つ(1)
    戻す "完了"
終わり

変数 タスク = 非同期実行(重い処理)
変数 結果 = 待機(タスク)
表示(結果)  // "完了"
```

### 待機(タスクID)

非同期タスクの完了を待ち、結果を返します。

### 全待機(タスク配列)

複数の非同期タスクすべての完了を待ちます。

```
変数 タスク1 = 非同期実行(処理A)
変数 タスク2 = 非同期実行(処理B)
変数 結果 = 全待機([タスク1, タスク2])
```

### タスク状態(タスクID)

タスクの現在の状態を返します（"実行中", "完了", "エラー"）。

---

## 並列処理

スレッドを使った並列実行を行います。

### 並列実行(関数配列)

複数の関数を並列に実行し、結果の配列を返します。

```
変数 結果 = 並列実行([
    関数(): 戻す 1 + 1 終わり,
    関数(): 戻す 2 + 2 終わり,
    関数(): 戻す 3 + 3 終わり
])
表示(結果)  // [2, 4, 6]
```

### 排他制御（ミューテックス）

```
変数 鍵 = 排他作成()
排他実行(鍵, 関数():
    // この中は同時に一つのスレッドのみ実行
    表示("排他処理")
終わり)
```

### チャネル（スレッド間通信）

| 関数 | 説明 |
|---|---|
| `チャネル作成([容量])` | チャネルを作成 |
| `チャネル送信(ch, 値)` | チャネルに値を送信 |
| `チャネル受信(ch)` | チャネルから値を受信 |
| `チャネル閉じる(ch)` | チャネルを閉じる |

---

## スケジューラ

タスクの定期実行や遅延実行を行います。

### 定期実行(関数, 間隔秒)

関数を指定間隔で繰り返し実行します。スケジュールIDを返します。

```
変数 id = 定期実行(関数():
    表示("定期処理")
終わり, 2.0)

待つ(7)
スケジュール停止(id)
```

### 遅延実行(関数, 遅延秒)

指定時間後に関数を一度実行します。

```
遅延実行(関数():
    表示("3秒後に実行")
終わり, 3.0)
```

### スケジュール停止(ID) / 全スケジュール停止()

スケジュールを停止します。

---

## WebSocket

WebSocketクライアント機能です。

| 関数 | 説明 |
|---|---|
| `WS接続(URL)` | WebSocketサーバーに接続 |
| `WS送信(接続, メッセージ)` | メッセージを送信 |
| `WS受信(接続 [, タイムアウト])` | メッセージを受信 |
| `WS切断(接続)` | 接続を切断 |
| `WS状態(接続)` | 接続状態を取得 |

```
変数 接続 = WS接続("ws://echo.websocket.org")
WS送信(接続, "こんにちは")
変数 応答 = WS受信(接続)
表示(応答)
WS切断(接続)
```

---

## 列挙型

定数グループを定義します。`列挙` ブロック内の各名前は 0 から順に数値が割り当てられた定数辞書になります。

```
列挙 方向:
    北
    南
    東
    西
終わり

表示(方向["北"])  // 0
表示(方向["南"])  // 1
表示(方向["東"])  // 2
表示(方向["西"])  // 3
```

---

## パターンマッチング

`照合` を使って値に対するパターンマッチングを行います。

```
関数 分類(値):
    照合 値:
        場合 1 => 戻す "一"
        場合 2 => 戻す "二"
        場合 3, 4, 5 => 戻す "三から五"
        場合 _ => 戻す "その他"
    終わり
終わり
```

- `場合 値 =>` で値にマッチした場合の処理を記述
- カンマ区切りで複数の値にマッチ可能
- `_` はワイルドカード（どの値にもマッチ）

---

## ジェネレータ

`生成関数` で値を逐次生成する関数を定義します。`譲渡` で値を生成します。

### 基本的な使い方

```
生成関数 数列():
    譲渡 1
    譲渡 2
    譲渡 3
終わり

変数 gen = 数列()
表示(次(gen))    // 1
表示(次(gen))    // 2
表示(完了(gen))  // 偽
表示(次(gen))    // 3
表示(完了(gen))  // 真
```

### ジェネレータ関数

| 関数 | 説明 |
|---|---|
| `次(ジェネレータ)` | 次の値を取得 |
| `完了(ジェネレータ)` | 全値を取得済みか判定 |
| `全値(ジェネレータ)` | 残りの全値を配列で取得 |

### フィボナッチ数列の例

```
生成関数 フィボナッチ(n):
    変数 a = 0
    変数 b = 1
    i を 0 から n 繰り返す
        譲渡 a
        変数 次の値 = a + b
        a = b
        b = 次の値
    終わり
終わり

変数 fib = フィボナッチ(10)
変数 全数列 = 全値(fib)
表示(全数列)  // [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]
```

---

## コマンドライン引数

スクリプトに渡されたコマンドライン引数は `引数` 配列で取得できます。

```bash
$ nihongo script.jp arg1 arg2 arg3
```

```
// script.jp
表示("引数の数:", 長さ(引数))
各 値 を 引数 の中:
    表示("引数:", 値)
終わり
```

---

## デバッグ

### デバッグモード起動

```bash
nihongo -d プログラム.jp
```

### デバッグコマンド

| キー | 動作 |
|---|---|
| Enter | 次のステップへ進む |
| v | 現在の変数を表示 |
| c | 継続実行（ステップモード終了） |

### その他のオプション

```bash
nihongo -h          # ヘルプ表示
nihongo -v          # バージョン表示
nihongo -t ファイル  # トークン表示
nihongo -a ファイル  # AST表示
```

---

## 集合（セット）

重複のない値のコレクションを扱います。

### 集合の作成・操作

```
変数 s = 集合(1, 2, 3, 2)       // → {1, 2, 3}（重複排除）
集合追加(s, 4)                   // → {1, 2, 3, 4}
集合削除(s, 2)                   // → {1, 3, 4}
表示(集合含む(s, 3))             // → 真
```

### 集合演算

```
変数 a = 集合(1, 2, 3)
変数 b = 集合(2, 3, 4)

和集合(a, b)                     // → {1, 2, 3, 4}
積集合(a, b)                     // → {2, 3}
差集合(a, b)                     // → {1}
```

---

## 演算子オーバーロード

クラスに特定のメソッドを定義することで、演算子の動作をカスタマイズできます。

### 対応する演算子メソッド

| 演算子 | メソッド名 |
|---|---|
| `+` | `足す(他)` |
| `-` | `引く(他)` |
| `*` | `掛ける(他)` |
| `/` | `割る(他)` |
| `%` | `剰余(他)` |
| `==` | `等しい(他)` |
| `!=` | `等しくない(他)` |
| `<` | `小さい(他)` |
| `>` | `大きい(他)` |
| `<=` | `以下(他)` |
| `>=` | `以上(他)` |

### 使用例

```
型 ベクトル:
    関数 初期化(自分, x, y):
        自分.x = x
        自分.y = y
    終わり
    
    関数 足す(自分, 他):
        戻す ベクトル(自分.x + 他.x, 自分.y + 他.y)
    終わり
    
    関数 等しい(自分, 他):
        戻す 自分.x == 他.x かつ 自分.y == 他.y
    終わり
終わり

変数 v1 = ベクトル(1, 2)
変数 v2 = ベクトル(3, 4)
変数 v3 = v1 + v2    // ベクトル(4, 6)
```

---

## デコレータ

`@` 構文で関数にデコレータを適用し、関数の振る舞いを拡張できます。

### 基本構文

```
関数 二倍化(f):
    戻す 関数(x):
        戻す f(x) * 2
    終わり
終わり

@二倍化
関数 値取得(x):
    戻す x + 1
終わり

表示(値取得(5))    // → 12  ((5+1)*2)
```

### 仕組み

`@デコレータ名` は内部的に以下のように展開されます：

```
関数 値取得(x):
    戻す x + 1
終わり
値取得 = 二倍化(値取得)
```

---

## アクセス修飾子

`_` プレフィックスが付いたフィールドはプライベートとして扱われ、クラス外部からのアクセスが制限されます。

### 使用例

```
型 口座:
    関数 初期化(自分, 残高):
        自分._残高 = 残高
    終わり
    
    関数 残高取得(自分):
        戻す 自分._残高
    終わり
終わり

変数 a = 口座(1000)
表示(a.残高取得())       // → 1000
// a._残高               // → エラー: プライベートフィールドにアクセスできません
```

### ルール

- `_` で始まるフィールド名はプライベート
- クラス内部（`自分.`）からはアクセス可能
- クラス外部からのアクセスは例外をスロー（try-catchで捕捉可能）

---

## テストフレームワーク

組み込みのテスト機能を使って、コードのテストを記述・実行できます。

### テストの定義と実行

```
テスト("足し算テスト", 関数():
    期待(1 + 2, 3, "1+2は3であるべき")
終わり)

テスト("文字列テスト", 関数():
    期待(長さ("hello"), 5)
終わり)

変数 結果 = テスト実行()
// 結果 = {成功: 2, 失敗: 0, 合計: 2}
```

### テスト関数

| 関数 | 説明 |
|---|---|
| `テスト(名前, 関数)` | テストケースを登録 |
| `テスト実行()` | 全テストを実行し結果を返す |
| `期待(実際, 期待値[, メッセージ])` | 値が等しいことを検証 |
| `期待エラー(関数)` | 関数がエラーを投げることを検証 |

---

## カスタム例外

構造化された例外を作成し、型ごとにキャッチできます。

### 例外の作成とスロー

```
試行:
    投げる 例外作成("計算エラー", "ゼロ除算が発生しました")
捕まえる エラー:
    もし エラー["種類"] == "計算エラー" なら
        表示("エラー: " + エラー["メッセージ"])
    終わり
終わり
```

### `例外作成(種類, メッセージ)`

構造化された例外辞書を返します：
```
{種類: "計算エラー", メッセージ: "ゼロ除算が発生しました"}
```

---

## ドキュメントコメント

関数やクラスにドキュメントを付与し、実行時に参照できます。

```
文書化("挨拶", "名前を受け取って挨拶文を返す関数")

関数 挨拶(名前):
    戻す "こんにちは、" + 名前 + "さん！"
終わり

表示(文書("挨拶"))    // → "名前を受け取って挨拶文を返す関数"
```

---

## 型エイリアス

既存の型名に別名を付け、`型判定` で使用できます。

```
型別名("整数", "数値")
型別名("テキスト", "文字列")

表示(型判定(42, "整数"))       // → 真
表示(型判定("hello", "テキスト"))  // → 真
```

---

## モジュール名前空間

モジュールをインポートする際にエイリアス名を付けて名前空間として使用できます。

### 基本構文

```
// 直接取り込み（従来通り）
取り込む "ユーティリティ"

// 名前空間付き取り込み
取り込む "数学ライブラリ" として 数学
```

### 名前空間の使用

```
// 数学ライブラリ.jp
関数 足す(a, b):
    戻す a + b
終わり

変数 バージョン = "1.0"
```

```
// メイン.jp
取り込む "数学ライブラリ" として 数学

表示(数学["足す"](3, 4))      // → 7
表示(数学["バージョン"])       // → "1.0"
```

---

## パッケージ管理

はじむには、外部パッケージの管理を行うパッケージマネージャが内蔵されています。

### マニフェストファイル（hajimu.json）

プロジェクトのパッケージ情報は `hajimu.json` で管理します。

```json
{
    "名前": "私のプロジェクト",
    "バージョン": "1.0.0",
    "説明": "プロジェクトの説明",
    "作者": "作者名",
    "メイン": "main.jp",
    "依存": {
        "my-library": "https://github.com/user/my-library.git"
    }
}
```

### CLIコマンド

```bash
# プロジェクトの初期化（hajimu.json を生成）
hajimu パッケージ 初期化

# パッケージの追加（GitHubリポジトリから）
hajimu パッケージ 追加 user/repo
hajimu パッケージ 追加 https://github.com/user/repo.git

# パッケージの追加（ローカルリポジトリから）
hajimu パッケージ 追加 /path/to/local/repo

# パッケージの削除
hajimu パッケージ 削除 パッケージ名

# インストール済みパッケージの一覧
hajimu パッケージ 一覧

# hajimu.json の依存パッケージを一括インストール
hajimu パッケージ インストール
```

英語エイリアスも使用できます：

```bash
hajimu pkg init
hajimu pkg add user/repo
hajimu pkg remove package-name
hajimu pkg list
hajimu pkg install
```

### ディレクトリ構成

```
プロジェクト/
├── hajimu.json              # マニフェストファイル
├── hajimu_packages/         # ローカルパッケージ格納先
│   ├── my-library/
│   │   ├── hajimu.json
│   │   └── main.jp
│   └── another-lib/
│       └── main.jp
└── main.jp                  # メインプログラム
```

グローバルパッケージは `~/.hajimu/packages/` に格納されます。

### パッケージの使用

インストールしたパッケージは `取り込む` でインポートできます。

```
// パッケージをそのまま取り込む（関数・変数が直接利用可能）
取り込む "my-library"

// 名前空間付きで取り込む
取り込む "my-library" として ライブラリ
表示(ライブラリ["関数名"](引数))
```

### パッケージの解決順序

パッケージ名で `取り込む` を実行すると、以下の順序で検索されます：

1. **ローカル**: `./hajimu_packages/<パッケージ名>/`
2. **グローバル**: `~/.hajimu/packages/<パッケージ名>/`

各パッケージ内では、エントリポイントとなるファイルを以下の順序で検索します：

1. `hajimu.json` の `メイン` フィールドで指定されたファイル
2. `main.jp`
3. `<パッケージ名>.jp`

### パッケージの作成

パッケージを作成するには、Gitリポジトリに以下を含めます：

```
my-package/
├── hajimu.json     # パッケージ情報（推奨）
├── main.jp         # エントリポイント
└── lib/            # 追加モジュール（任意）
    └── utils.jp
```

`hajimu.json` で依存パッケージを指定すると、インストール時に再帰的に依存パッケージもインストールされます。

---

## C拡張プラグイン

C言語（または共有ライブラリを生成できる任意の言語）で書かれたネイティブプラグインを「はじむ」に読み込むことができます。
プラグインは統一拡張子 `.hjp`（Hajimu Plugin）でビルドし、Windows/macOS/Linux 共通で使用できます。

### プラグインの使用

**拡張子なしのパッケージ名だけでインポートできます。**

```
// 名前空間付きインポート（推奨）
取り込む "math_plugin" として 数学P
表示(数学P["二乗"](5))       // → 25
表示(数学P["階乗"](6))       // → 720

// 直接インポート
取り込む "math_plugin"
表示(二乗(5))                // → 25

// .hjp を明示的に指定してもOK
取り込む "math_plugin.hjp" として 数学P
```

### プラグインの検索順序

拡張子なしで `取り込む "名前"` した場合、以下の順序で `.hjp` ファイルを自動検索します：

1. **呼び出し元ファイルからの相対パス**: `<呼出元のディレクトリ>/名前.hjp`
2. **カレントディレクトリ**: `./名前.hjp`
3. **ローカルパッケージ**: `./hajimu_packages/名前.hjp`、`./hajimu_packages/名前/名前.hjp`
4. **グローバルプラグイン**: `~/.hajimu/plugins/名前.hjp`

### プラグインのメタ情報

名前空間付きインポート時、プラグインのメタ情報にもアクセスできます。

```
取り込む "my_plugin" として P
表示(P["__名前__"])         // プラグイン名
表示(P["__バージョン__"])   // バージョン
表示(P["__作者__"])         // 作者
表示(P["__説明__"])         // 説明
```

### プラグインの開発

#### 1. ヘッダーのインクルード

`include/hajimu_plugin.h` をインクルードします。

```c
#include "hajimu_plugin.h"
```

#### 2. 関数の実装

プラグイン関数は `Value fn(int argc, Value *argv)` のシグネチャです。

```c
static Value fn_hello(int argc, Value *argv) {
    (void)argc;
    if (argv[0].type == VALUE_STRING) {
        printf("こんにちは、%sさん！\n", argv[0].string.data);
    }
    return hajimu_null();
}
```

ヘルパー関数:

| 関数 | 説明 |
|------|------|
| `hajimu_null()` | NULL値を作成 |
| `hajimu_number(n)` | 数値を作成 |
| `hajimu_bool(b)` | 真偽値を作成 |
| `hajimu_string(s)` | 文字列を作成（コピー） |
| `hajimu_array()` | 空の配列を作成 |
| `hajimu_array_push(arr, elem)` | 配列に要素を追加 |

#### 3. 関数テーブルと初期化

```c
// 関数テーブル
static HajimuPluginFunc functions[] = {
    {"挨拶", fn_hello, 1, 1},  // {名前, 関数, 最小引数, 最大引数}
};

// 初期化関数（必須）
HAJIMU_PLUGIN_EXPORT HajimuPluginInfo *hajimu_plugin_init(void) {
    static HajimuPluginInfo info = {
        .name           = "my_plugin",
        .version        = "1.0.0",
        .author         = "作者名",
        .description    = "プラグインの説明",
        .functions      = functions,
        .function_count = sizeof(functions) / sizeof(functions[0]),
    };
    return &info;
}
```

#### 4. コンパイル（全OS共通で `.hjp` を出力）

```bash
# macOS
gcc -shared -fPIC -I/path/to/hajimu/include -o my_plugin.hjp my_plugin.c

# Linux
gcc -shared -fPIC -I/path/to/hajimu/include -o my_plugin.hjp my_plugin.c -lm

# Windows (MinGW)
gcc -shared -I/path/to/hajimu/include -o my_plugin.hjp my_plugin.c

# Windows (MSVC)
cl /LD /Fe:my_plugin.hjp my_plugin.c
```

### 対応言語

共有ライブラリを生成できる言語であれば、C以外でもプラグインを開発できます。
すべて出力ファイル名を `.hjp` にするだけです。

| 言語 | コンパイル例 |
|------|----------|
| C | `gcc -shared -fPIC -o plugin.hjp plugin.c` |
| C++ | `g++ -shared -fPIC -o plugin.hjp plugin.cpp` |
| Rust | `cargo build --release`（`cdylib` crate-type、出力を `.hjp` にリネーム） |
| Go | `go build -buildmode=c-shared -o plugin.hjp` |
| Zig | `zig build-lib -dynamic`（出力を `.hjp` にリネーム） |

**要件**: `hajimu_plugin_init` シンボルをCリンケージ（`extern "C"`）でエクスポートし、`HajimuPluginInfo *` を返すこと。

### プラグインランタイムコールバック

v1.2.0 以降、プラグインからはじむの関数（ユーザー定義関数、ラムダ、ビルトイン関数）を呼び出すことができます。

```c
// プラグイン側のコード
#include "hajimu_plugin.h"

// ランタイム注入エントリポイント（自動呼び出し）
HAJIMU_PLUGIN_EXPORT void hajimu_plugin_set_runtime(HajimuRuntime *rt) {
    __hajimu_runtime = rt;
}

// プラグイン関数内で、はじむの関数を呼び出す
static Value fn_example(int argc, Value *argv) {
    if (argc >= 1 && (argv[0].type == VALUE_FUNCTION || argv[0].type == VALUE_BUILTIN)) {
        Value arg = hajimu_string("Hello");
        return hajimu_call(&argv[0], 1, &arg);  // はじむ関数を呼び出し
    }
    return hajimu_null();
}
```

これにより、Express スタイルのコールバック関数ハンドラなど、プラグインとはじむコードの高度な連携が可能になります。

---

## リスト内包表記

リスト内包表記は、配列から新しい配列を簡潔に生成する方法です。

### 基本構文

```
[式 を 変数 から 反復対象]
```

### 使用例

#### 基本形式

```
// 各要素を2倍にした配列を生成
変数 数字 = [1, 2, 3, 4, 5]
変数 倍 = [n * 2 を n から 数字]
表示(倍)  // → [2, 4, 6, 8, 10]

// 文字列の各文字をアッパーケースに
変数 文 = "hello"
変数 大 = [c を c から 文]
表示(大)  // → ['h', 'e', 'l', 'l', 'o']
```

#### 条件付き（フィルタリング）

```
// 3より大きい数字のみを抽出
変数 数字 = [1, 2, 3, 4, 5]
変数 大きい = [n を n から 数字 もし n > 3]
表示(大きい)  // → [4, 5]

// 条件と式を組み合わせ
変数 偶数 = [n * 10 を n から 数字 もし n % 2 == 0]
表示(偶数)  // → [20, 40]
```

#### 複雑な式

```
// 複数の操作を組み合わせ
変数 結果 = [n * n + 1 を n から [1, 2, 3]]
表示(結果)  // → [2, 5, 10]

// 辞書のキーから配列を生成
変数 dict = {"a": 1, "b": 2, "c": 3}
変数 キー = [k を k から dict]
表示(キー)  // → ["a", "b", "c"]
```

### パフォーマンス

リスト内包表記は以下のような状況で最適化されています：

- シンプルな配列フィルタリング
- 配列要素の変換
- 複数の配列操作の連鎖

### 注意事項

- 反復対象は配列、文字列、辞書のいずれかである必要があります
- 変数名は有効な識別子である必要があります
- 条件式が複雑な場合は、ラムダ式や関数の使用も検討してください

---

## 実行例

```
// hello.jp
表示("こんにちは、世界！")
```

```bash
$ nihongo hello.jp
こんにちは、世界！
```

---

## バージョン情報

- バージョン: 1.2.0
- 作者: Reo Shiozawa
