// 新機能テスト

変数 成功数 = 0
変数 失敗数 = 0

関数 確認(名前, 値, 期待):
    もし 値 == 期待 なら
        成功数 = 成功数 + 1
    それ以外
        失敗数 = 失敗数 + 1
        表示("✗ " + 名前 + ": 期待=" + 文字列化(期待) + ", 実際=" + 文字列化(値))
    終わり
終わり

// =====================
// 1. 負のインデックス
// =====================
変数 配列1 = [10, 20, 30, 40, 50]
確認("負のインデックス: 配列[-1]", 配列1[-1], 50)
確認("負のインデックス: 配列[-2]", 配列1[-2], 40)
確認("負のインデックス: 配列[-5]", 配列1[-5], 10)

// =====================
// 2. 部分文字列
// =====================
確認("部分文字列: 基本", 部分文字列("hello world", 6), "world")
確認("部分文字列: 長さ指定", 部分文字列("hello world", 0, 5), "hello")
確認("部分文字列: 負の開始", 部分文字列("hello", -3), "llo")

// =====================
// 3. 始まる・終わる
// =====================
確認("始まる: 真", 始まる("hello world", "hello"), 真)
確認("始まる: 偽", 始まる("hello world", "world"), 偽)
確認("終わる: 真", 終わる("hello world", "world"), 真)
確認("終わる: 偽", 終わる("hello world", "hello"), 偽)

// =====================
// 4. 文字コード・コード文字
// =====================
確認("文字コード: A", 文字コード("A"), 65)
確認("コード文字: 65", コード文字(65), "A")
確認("コード文字: 97", コード文字(97), "a")

// =====================
// 5. 繰り返し
// =====================
確認("繰り返し: 基本", 繰り返し("ab", 3), "ababab")
確認("繰り返し: 0回", 繰り返し("ab", 0), "")

// =====================
// 6. 末尾削除（pop）
// =====================
変数 配列2 = [1, 2, 3, 4, 5]
変数 末尾 = 末尾削除(配列2)
確認("末尾削除: 戻り値", 末尾, 5)

// =====================
// 7. 探す（find）
// =====================
変数 配列3 = [1, 2, 3, 4, 5]
変数 見つかった = 探す(配列3, 関数(x): 戻す x > 3 終わり)
確認("探す: 見つかった", 見つかった, 4)

変数 見つからない = 探す(配列3, 関数(x): 戻す x > 10 終わり)
確認("探す: 見つからない", 見つからない, 無)

// =====================
// 8. 全て・一つでも
// =====================
変数 配列4 = [2, 4, 6, 8]
確認("全て: 偶数のみ", 全て(配列4, 関数(x): 戻す x % 2 == 0 終わり), 真)
確認("全て: 偽", 全て([1, 2, 3], 関数(x): 戻す x > 1 終わり), 偽)

確認("一つでも: 真", 一つでも([1, 2, 3], 関数(x): 戻す x == 2 終わり), 真)
確認("一つでも: 偽", 一つでも([1, 2, 3], 関数(x): 戻す x > 5 終わり), 偽)

// =====================
// 9. 一意（unique）
// =====================
変数 重複 = [1, 2, 2, 3, 3, 3, 4]
変数 結果一意 = 一意(重複)
確認("一意: 長さ", 長さ(結果一意), 4)

// =====================
// 10. 圧縮（zip）
// =====================
変数 名前リスト = ["太郎", "花子"]
変数 年齢リスト = [25, 30]
変数 組合せ = 圧縮(名前リスト, 年齢リスト)
確認("圧縮: 長さ", 長さ(組合せ), 2)
確認("圧縮: 1番目[0]", 組合せ[0][0], "太郎")
確認("圧縮: 1番目[1]", 組合せ[0][1], 25)

// =====================
// 11. 平坦化（flat）
// =====================
変数 入れ子 = [[1, 2], [3, 4], [5]]
変数 平 = 平坦化(入れ子)
確認("平坦化: 長さ", 長さ(平), 5)
確認("平坦化: 要素", 平[0], 1)
確認("平坦化: 末尾", 平[4], 5)

// =====================
// 12. 挿入
// =====================
変数 配列5 = [1, 2, 4, 5]
変数 挿入結果 = 挿入(配列5, 2, 3)
確認("挿入: 長さ", 長さ(挿入結果), 5)
確認("挿入: 要素", 挿入結果[2], 3)

// =====================
// 13. 比較ソート
// =====================
変数 配列6 = [3, 1, 4, 1, 5]
変数 降順 = 比較ソート(配列6, 関数(甲, 乙): 戻す 乙 - 甲 終わり)
確認("比較ソート: 降順[0]", 降順[0], 5)
確認("比較ソート: 降順[1]", 降順[1], 4)

// =====================
// 14. 数学関数
// =====================
確認("正弦: sin(0)", 正弦(0), 0)
確認("余弦: cos(0)", 余弦(0), 1)
確認("正接: tan(0)", 正接(0), 0)
確認("対数: ln(1)", 対数(1), 0)
確認("常用対数: log10(100)", 常用対数(100), 2)
確認("円周率", 円周率 > 3.14, 真)
確認("自然対数の底", 自然対数の底 > 2.71, 真)

変数 乱数値 = 乱数整数(1, 10)
確認("乱数整数: 範囲内", 乱数値 >= 1, 真)
確認("乱数整数: 範囲内2", 乱数値 <= 10, 真)

// =====================
// 15. ファイル追記・ディレクトリ
// =====================
書き込む("/tmp/jp_test_append.txt", "行1\n")
追記("/tmp/jp_test_append.txt", "行2\n")
変数 内容 = 読み込む("/tmp/jp_test_append.txt")
確認("追記: 内容", 内容, "行1\n行2\n")

// =====================
// 16. 表明（assert）
// =====================
変数 表明結果 = 表明(真, "これは通過する")
確認("表明: 真の場合", 表明結果, 真)

// =====================
// 17. 型判定
// =====================
確認("型判定: 数値", 型判定(42, "数値"), 真)
確認("型判定: 文字列", 型判定("hello", "文字列"), 真)
確認("型判定: 配列", 型判定([1, 2], "配列"), 真)
確認("型判定: 真偽", 型判定(真, "真偽"), 真)
確認("型判定: 無", 型判定(無, "無"), 真)
確認("型判定: 不一致", 型判定(42, "文字列"), 偽)

// =====================
// 18. 親クラス呼び出し（super）
// =====================
型 動物:
    初期化(名前):
        自分.名前 = 名前
    終わり
    
    関数 鳴く():
        戻す "..."
    終わり
    
    関数 情報():
        戻す 自分.名前
    終わり
終わり

型 犬 継承 動物:
    初期化(名前, 種類):
        親.初期化(名前)
        自分.種類 = 種類
    終わり
    
    関数 鳴く():
        戻す "ワン！"
    終わり
    
    関数 詳細():
        変数 基本 = 親.情報()
        戻す 基本 + "(" + 自分.種類 + ")"
    終わり
終わり

変数 犬1 = 新規 犬("ポチ", "柴犬")
確認("super: 初期化", 犬1.名前, "ポチ")
確認("super: 種類", 犬1.種類, "柴犬")
確認("super: オーバーライド", 犬1.鳴く(), "ワン！")
確認("super: 親メソッド呼出", 犬1.詳細(), "ポチ(柴犬)")

// =====================
// 19. クラスの型判定
// =====================
確認("型判定: クラス名", 型判定(犬1, "犬"), 真)
確認("型判定: 親クラス名", 型判定(犬1, "動物"), 真)
確認("型判定: 不一致", 型判定(犬1, "猫"), 偽)

// =====================
// 20. 三項演算子
// =====================
変数 三項1 = 真 ? "はい" : "いいえ"
確認("三項演算子: 真", 三項1, "はい")

変数 三項2 = 偽 ? "はい" : "いいえ"
確認("三項演算子: 偽", 三項2, "いいえ")

変数 三項3 = 5 > 3 ? "大きい" : "小さい"
確認("三項演算子: 比較", 三項3, "大きい")

// =====================
// 21. null合体演算子
// =====================
変数 合体1 = 無 ?? "デフォルト"
確認("null合体: null", 合体1, "デフォルト")

変数 合体2 = "値あり" ?? "デフォルト"
確認("null合体: 非null", 合体2, "値あり")

変数 合体3 = 0 ?? "デフォルト"
確認("null合体: 0は非null", 合体3, 0)

// =====================
// 22. 分割代入
// =====================
変数 [甲, 乙, 丙] = [10, 20, 30]
確認("分割代入: 甲", 甲, 10)
確認("分割代入: 乙", 乙, 20)
確認("分割代入: 丙", 丙, 30)

// =====================
// 23. 可変長引数
// =====================
関数 合計(初期値, *数値群):
    変数 合計値 = 初期値
    変数 個数 = 長さ(数値群)
    変数 添字 = 0
    条件 添字 < 個数 の間
        合計値 = 合計値 + 数値群[添字]
        添字 = 添字 + 1
    終わり
    戻す 合計値
終わり

確認("可変長引数: 3つ", 合計(0, 1, 2, 3), 6)
確認("可変長引数: 1つ", 合計(100, 50), 150)
確認("可変長引数: 0個", 合計(42), 42)

関数 最初と残り(最初, *残り):
    戻す 文字列化(最初) + ":" + 文字列化(長さ(残り))
終わり

確認("可変長引数: 残り", 最初と残り("a", "b", "c", "d"), "a:3")

// =====================
// 24. スプレッド演算子
// =====================
関数 三つの和(甲, 乙, 丙):
    戻す 甲 + 乙 + 丙
終わり

変数 引数配列 = [10, 20, 30]
確認("スプレッド: 基本", 三つの和(...引数配列), 60)

関数 混合(甲, 乙, 丙, 丁):
    戻す 甲 * 1000 + 乙 * 100 + 丙 * 10 + 丁
終わり
変数 残り = [30, 40]
確認("スプレッド: 混合", 混合(10, 20, ...残り), 12340)

確認("スプレッド: 組み込み関数", 長さ(...[[1,2,3]]), 3)

// =====================
// 25. 列挙型
// =====================
列挙 方向:
    北
    南
    東
    西
終わり

確認("列挙型: 自動値", 方向.北, 0)
確認("列挙型: 連番", 方向.西, 3)

列挙 状態:
    開始 = 10
    処理中 = 20
    完了 = 30
終わり

確認("列挙型: カスタム値", 状態.処理中, 20)
確認("列挙型: 比較", 方向.東 == 2, 真)

// =====================
// 26. パターンマッチ
// =====================
関数 数値判定(数):
    変数 結果 = "?"
    照合 数:
        場合 1 => 結果 = "一"
        場合 2 => 結果 = "二"
        場合 3 => 結果 = "三"
        既定 => 結果 = "他"
    終わり
    戻す 結果
終わり

確認("パターンマッチ: 基本", 数値判定(2), "二")
確認("パターンマッチ: 既定", 数値判定(99), "他")

関数 複数パターン(値):
    変数 結果 = ""
    照合 値:
        場合 1, 2, 3 => 結果 = "小"
        場合 4, 5, 6 => 結果 = "中"
        場合 _ => 結果 = "大"
    終わり
    戻す 結果
終わり

確認("パターンマッチ: 複数", 複数パターン(2), "小")
確認("パターンマッチ: ワイルドカード", 複数パターン(100), "大")

// =====================
// 27. ジェネレータ
// =====================
生成関数 数列(最大):
    変数 現在 = 1
    条件 現在 <= 最大 の間
        譲渡 現在
        現在 = 現在 + 1
    終わり
終わり

変数 gen = 数列(5)
確認("ジェネレータ: 次の値1", 次(gen), 1)
確認("ジェネレータ: 次の値2", 次(gen), 2)
確認("ジェネレータ: 完了チェック", 完了(gen), 偽)

変数 残り = 全値(gen)
確認("ジェネレータ: 全値取得", 長さ(残り), 3)
確認("ジェネレータ: 完了後", 完了(gen), 真)

生成関数 フィボナッチ(数):
    変数 甲 = 0
    変数 乙 = 1
    回 を 0 から 数 繰り返す
        譲渡 甲
        変数 一時 = 甲 + 乙
        甲 = 乙
        乙 = 一時
    終わり
終わり

変数 fib = フィボナッチ(7)
変数 fib値 = 全値(fib)
確認("ジェネレータ: フィボナッチ長さ", 長さ(fib値), 8)
確認("ジェネレータ: フィボナッチ先頭", fib値[0], 0)
確認("ジェネレータ: フィボナッチ7番目", fib値[6], 8)

// =====================
// 複合代入演算子 %=, **=
// =====================
変数 mod_test = 10
mod_test %= 3
確認("複合代入: %=", mod_test, 1)

変数 pow_test = 2
pow_test **= 8
確認("複合代入: **=", pow_test, 256)

変数 mod_test2 = 17
mod_test2 %= 5
確認("複合代入: %= (17%5)", mod_test2, 2)

// =====================
// 辞書キー・値ペア展開
// =====================
変数 辞書テスト = {"名前": "太郎", "年齢": "25", "都市": "東京"}
変数 キー結果 = []
変数 値結果 = []
各 キー, 値 を 辞書テスト の中:
    追加(キー結果, キー)
    追加(値結果, 値)
終わり
確認("辞書展開: キー数", 長さ(キー結果), 3)
確認("辞書展開: 最初のキー", キー結果[0], "名前")
確認("辞書展開: 最初の値", 値結果[0], "太郎")
確認("辞書展開: 2番目の値", 値結果[1], "25")

// 辞書展開で合計計算
変数 点数辞書 = {"国語": 80, "数学": 90, "英語": 70}
変数 合計点 = 0
各 科目, 点数 を 点数辞書 の中:
    合計点 = 合計点 + 点数
終わり
確認("辞書展開: 合計計算", 合計点, 240)

// =====================
// 16進・2進リテラル
// =====================
確認("16進: 0xFF", 0xFF, 255)
確認("16進: 0x10", 0x10, 16)
確認("16進: 0xA", 0xA, 10)
確認("2進: 0b1010", 0b1010, 10)
確認("2進: 0b11111111", 0b11111111, 255)
確認("2進: 0b100", 0b100, 4)

// =====================
// パス操作
// =====================
確認("パス結合", パス結合("/home/user", "file.txt"), "/home/user/file.txt")
確認("パス結合: 末尾スラッシュ", パス結合("/home/user/", "file.txt"), "/home/user/file.txt")
確認("ファイル名", ファイル名("/home/user/file.txt"), "file.txt")
確認("ディレクトリ名", ディレクトリ名("/home/user/file.txt"), "/home/user")
確認("拡張子", 拡張子("document.pdf"), ".pdf")
確認("拡張子: なし", 拡張子("README"), "")

// =====================
// Base64
// =====================
確認("Base64エンコード", Base64エンコード("Hello"), "SGVsbG8=")
確認("Base64デコード", Base64デコード("SGVsbG8="), "Hello")
確認("Base64往復", Base64デコード(Base64エンコード("テスト")), "テスト")

// =====================
// 静的メソッド
// =====================
型 計算:
    初期化():
    終わり

    静的 関数 足す(a, b):
        戻す a + b
    終わり

    静的 関数 掛ける(a, b):
        戻す a * b
    終わり
終わり

確認("静的メソッド: 足す", 計算.足す(3, 5), 8)
確認("静的メソッド: 掛ける", 計算.掛ける(4, 6), 24)

// =====================
// toStringプロトコル
// =====================
型 座標:
    初期化(x, y):
        自分.x = x
        自分.y = y
    終わり

    関数 文字列化():
        戻す "(" + 文字列化(自分.x) + ", " + 文字列化(自分.y) + ")"
    終わり
終わり

変数 点 = 新規 座標(3, 4)
確認("toString: 文字列化", 文字列化(点), "(3, 4)")

// =====================
// セット（集合）型テスト
// =====================

// 集合の作成（重複排除）
変数 s1 = 集合(1, 2, 3, 2, 1)
確認("セット: 重複排除", 長さ(s1), 3)

// 集合含む
確認("セット: 含む（真）", 集合含む(s1, 2), 真)
確認("セット: 含む（偽）", 集合含む(s1, 5), 偽)

// 集合追加
変数 s2 = 集合追加(s1, 4)
確認("セット: 追加", 長さ(s2), 4)
変数 s3 = 集合追加(s1, 2)
確認("セット: 重複追加", 長さ(s3), 3)

// 集合削除
変数 s4 = 集合削除(s1, 2)
確認("セット: 削除", 長さ(s4), 2)
確認("セット: 削除後含まない", 集合含む(s4, 2), 偽)

// 和集合
変数 sA = 集合(1, 2, 3)
変数 sB = 集合(3, 4, 5)
変数 s和 = 和集合(sA, sB)
確認("セット: 和集合", 長さ(s和), 5)

// 積集合
変数 s積 = 積集合(sA, sB)
確認("セット: 積集合", 長さ(s積), 1)
確認("セット: 積集合の値", 集合含む(s積, 3), 真)

// 差集合
変数 s差 = 差集合(sA, sB)
確認("セット: 差集合", 長さ(s差), 2)
確認("セット: 差集合に含む", 集合含む(s差, 1), 真)
確認("セット: 差集合に含まない", 集合含む(s差, 3), 偽)

// =====================
// 演算子オーバーロードテスト
// =====================

型 ベクトル:
    初期化(x, y):
        自分.x = x
        自分.y = y
    終わり

    関数 足す(他):
        戻す 新規 ベクトル(自分.x + 他.x, 自分.y + 他.y)
    終わり

    関数 引く(他):
        戻す 新規 ベクトル(自分.x - 他.x, 自分.y - 他.y)
    終わり

    関数 等しい(他):
        戻す 自分.x == 他.x かつ 自分.y == 他.y
    終わり

    関数 文字列化():
        戻す "(" + 文字列化(自分.x) + ", " + 文字列化(自分.y) + ")"
    終わり
終わり

変数 v1 = 新規 ベクトル(1, 2)
変数 v2 = 新規 ベクトル(3, 4)
変数 v3 = v1 + v2
確認("演算子OL: 足す", 文字列化(v3), "(4, 6)")

変数 v4 = v2 - v1
確認("演算子OL: 引く", 文字列化(v4), "(2, 2)")

確認("演算子OL: 等しい（真）", v1 == 新規 ベクトル(1, 2), 真)
確認("演算子OL: 等しい（偽）", v1 == v2, 偽)

// =====================
// テストフレームワークテスト
// =====================

// テストケースを登録
テスト("足し算テスト", 関数():
    期待(1 + 1, 2, "1+1=2")
    期待(2 + 3, 5, "2+3=5")
終わり)

テスト("文字列テスト", 関数():
    期待(長さ("こんにちは"), 5, "文字列の長さ")
    期待("a" + "b", "ab", "文字列結合")
終わり)

テスト("配列テスト", 関数():
    変数 arr = [1, 2, 3]
    期待(長さ(arr), 3, "配列の長さ")
終わり)

// テスト実行して結果を取得
変数 結果 = テスト実行()
確認("テストFW: 成功数", 結果["成功"], 3)
確認("テストFW: 失敗数", 結果["失敗"], 0)
確認("テストFW: 合計", 結果["合計"], 3)

// =====================
// カスタム例外テスト
// =====================

// 例外作成
変数 exc = 例外作成("入力エラー", "値が不正です")
確認("例外: 種類", exc["種類"], "入力エラー")
確認("例外: メッセージ", exc["メッセージ"], "値が不正です")

// 辞書を例外として投げてキャッチ
変数 捕獲した種類 = ""
試行:
    投げる 例外作成("計算エラー", "ゼロ除算")
捕獲 e:
    捕獲した種類 = e["種類"]
終わり
確認("例外: キャッチ", 捕獲した種類, "計算エラー")

// =====================
// ドキュメントコメントテスト
// =====================

文書化("足し算", "二つの数を足して返す関数")
確認("文書: 取得", 文書("足し算"), "二つの数を足して返す関数")
確認("文書: 存在しない", 文書("未定義"), 無)

// 上書き
文書化("足し算", "更新済みの説明")
確認("文書: 上書き", 文書("足し算"), "更新済みの説明")

// =====================
// アクセス修飾子テスト
// =====================

型 銀行口座:
    初期化(名義, 残高):
        自分.名義 = 名義
        自分._残高 = 残高
    終わり

    関数 残高取得():
        戻す 自分._残高
    終わり

    関数 入金(額):
        自分._残高 = 自分._残高 + 額
    終わり
終わり

変数 口座 = 新規 銀行口座("太郎", 1000)
確認("アクセス: 公開フィールド", 口座.名義, "太郎")
確認("アクセス: メソッドで非公開取得", 口座.残高取得(), 1000)

口座.入金(500)
確認("アクセス: メソッドで非公開変更", 口座.残高取得(), 1500)

// 外部からの非公開アクセスはエラー
変数 アクセス成功 = 偽
試行:
    変数 x = 口座._残高
    アクセス成功 = 真
捕獲 e:
    アクセス成功 = 偽
終わり
確認("アクセス: 外部非公開ブロック", アクセス成功, 偽)

// =====================
// デコレータテスト
// =====================

// ログデコレータ: 関数の戻り値を2倍にする
関数 二倍化(f):
    戻す 関数(*引数):
        変数 結果 = f(...引数)
        戻す 結果 * 2
    終わり
終わり

@二倍化
関数 数値取得():
    戻す 5
終わり

確認("デコレータ: 二倍化", 数値取得(), 10)

// 引数付き関数のデコレータ
関数 キャッシュ化(f):
    戻す 関数(x):
        戻す f(x) + 100
    終わり
終わり

@キャッシュ化
関数 処理(x):
    戻す x * x
終わり

確認("デコレータ: 引数付き", 処理(3), 109)

// =====================
// 型エイリアス
// =====================
型別名("整数", "数値")
型別名("テキスト", "文字列")
確認("型エイリアス: 整数→数値", 型判定(42, "整数"), 真)
確認("型エイリアス: テキスト→文字列", 型判定("hello", "テキスト"), 真)
確認("型エイリアス: 不一致", 型判定("hello", "整数"), 偽)

// =====================
// リスト内包表記
// =====================
確認("リスト内包表記: 基本", [n * 2 を n から [1, 2, 3]], [2, 4, 6])
確認("リスト内包表記: 条件付き1", [n を n から [1, 2, 3, 4, 5] もし n > 2], [3, 4, 5])
確認("リスト内包表記: 条件付き2", [n * n を n から [1, 2, 3]もし n > 1], [4, 9])
確認("リスト内包表記: 空", [n を n から [] もし 真], [])
確認("リスト内包表記: 単一要素", [n + 10 を n から [5]], [15])

// 複雑な式
確認("リスト内包表記: 複雑な式", [n * 2 + 1 を n から [0, 1, 2]], [1, 3, 5])

// =====================
// 結果表示
// =====================
表示("")
表示("===== 新機能テスト結果 =====")
表示(文字列化(成功数) + "/" + 文字列化(成功数 + 失敗数) + " テスト成功")
もし 失敗数 == 0 なら
    表示("✓ 全テスト通過！")
それ以外
    表示("✗ " + 文字列化(失敗数) + " 個のテスト失敗")
終わり
